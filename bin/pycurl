#!/usr/bin/env python3

'''
Basically, this is nothing but

.. code-block::bash

   $ curl ${CURL_ARGS} | python -mjson.tool | pygmentize -l json

only in python. I don't want to battle bash on reinterpreting
quoted cURL args when trying to wrap this into a script
or aliasing it.

No cli help whatsoever, used only as another tool for quick
and dirty interacting with the server backend via REST API.

Example usage:

.. code-block::bash

   $ pycurl -i -H "Authorization: JWT my-token" http://localhost:8000/api/v2/projects/1/testcases/
   $ pycurl -X PATCH -H "Authorization: JWT my-token" -d '{"name": "foo"}' http://localhost:8000/api/v2/projects/1/testcases/1/

The header `Content-Type: application/json` will be inserted
automatically if not passed via cli.

Disclaimer: no warranty whatsoever, use at your own risk.

TODO: replace mimicking ``pygmentize`` cli call with calling
the appropriate pygments function.
'''


import argparse
import json
import pygments.cmdline
import subprocess
import sys


#----------------------------------------------------------------------
def main():
    ''''''
    _, args = argparse.ArgumentParser().parse_known_args()

    if 'Content-Type: application/json' not in args:
        args += ['-H', 'Content-Type: application/json']

    cmd = ['curl'] + args
    headers, payload = subprocess.run(
        cmd, stdout=subprocess.PIPE,
        universal_newlines=True
    ).stdout.strip().split('{', 1)
    print(headers)

    payload_formatted = json.dumps(
        json.loads('{' + payload), indent=4
    )

    cmd = ['pygmentize', '-l', 'json']
    p = subprocess.Popen(
        cmd, stdin=subprocess.PIPE, shell=False
    ).communicate(input=payload_formatted.encode())
    return 0


if __name__ == '__main__':
    sys.exit(main())
